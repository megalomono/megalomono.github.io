<!DOCTYPE html>

<html lang="es">
<head>

  <meta charset="utf-8">

  <title>Alfonso Pérez</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE" />

  <!-- Stylesheets -->
  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/assets/css/bootstrap.min.css" type="text/css" media="screen">
  <link rel="stylesheet" href="/assets/css/bootstrap-theme.min.css" type="text/css" media="screen">
  <link rel="stylesheet" href="/assets/css/styles.css" type="text/css"/>
  
  <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
  <!--[if IE]>
  <meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE" />
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
</head>

<body>
  <header id="header">
    <div class="container">
      <div class="row">
        <div class="col-md-10">
          <h1>alfonso pérez</h1>
        </div>
      </div>
      <div class="row">
        <div class="col-md-12">
          <h4>ingeniero de software y buen tío en general</h4>
        </div>
      </div>
    </div>
  </header>

  <section id="content">
    <div class="container">
      <div class="row">
        <div class="col-md-12 text-right">
          <a href="/index.html">Volver</a>
        </div>
      </div>
      <div class="row">
        <div class="col-md-6">
          <div class="section-title">
            <h2>Programadores y albañiles</h2>
            <p><i>05/01/2015</i></p>
          </div>
          <p>Hace unos días, durante una comida de Navidad (una de esas a las que sí apetece ir), comentaba con un buen amigo que no entendía muy bien que utilidad podía tener un currículum en nuestra profesión y que, en el momento de contratar a alguien, sería mucho más lógico pedirle que escribiese algo de código o bien que mostrase algo que tuviese hecho. Su respuesta fue que eso está bien si quieres pasarte la vida programando, pero que lo verdaderamente interesante en este mundillo era diseñar sistemas. Esto derivó en una discusión sobre el desarrollo iterativo, Scrum y el Proceso Unificado de Desarrollo, y el asunto quedó ahí. Pero luego, tras digerir la copiosa comida, me quedé dándole vueltas a la conversación y pensando en el porqué de esa distinción entre diseño y programación.</p>
          <p>Con frecuencia he escuchado comparaciones entre el mundo del desarrollo de software y el de la construcción, en las que el ingeniero informático cumpliría el papel del arquitecto, diseñando el sistema mediante detallados diagramas UML y otros documentos complementarios. La implementación de este diseño sería el equivalente a la construcción del edificio y la llevarían a cabo los programadores. Pero llegados a este punto, el símil se viene abajo.</p>
          <p>En primer lugar, nunca he tenido muy claro quienes son los "programadores". ¿Son ingenieros que se han portado mal? ¿Quizá ingenieros en estado larvario antes de eclosionar? ¿Son los padres? Supongamos, puestos a imaginar, que los "programadores" son ingenieros bisoños que comienzan su andadura por el mundo. Supongamos también que, cuando adquieran cierta experiencia, se convertirán en ingenieros hechos y derechos, y dejarán de programar para pasar a diseñar, blandiendo todo el poder del UML con sus poderosas e ingenieriles manos. La conclusión de esto es que nunca habría programadores experimentados, porque cuando adquirieran suficiente experiencia se alejarían de las trincheras. Estaríamos eternamente en manos de albañiles novatos. ¡Horror! En cualquier caso, este razonamiento bastaría para desbaratar la comparación; desde luego, el arquitecto no es un albañil con experiencia. Lo que me lleva al segundo punto.</p>
          <p>Un albañil no evoluciona en arquitecto con el paso de los años por la sencilla razón de que sus trabajos son totalmente distintos. Pero, ¿existe esa diferencia entre el diseño de software y su implementación? Partamos del hecho de que, durante la construcción de un edificio, los obreros siguen una especificación formal definida por el arquitecto. La única especificación formal explícita e interpretable de forma inequívoca en el mundo del software es el código; solo los lenguajes de programación son lo suficientemente formales como para definir un sistema al detalle. Lo siento por los fanáticos del UML, pero no es un lenguaje lo suficientemente preciso y nunca fue intención de sus creadores que lo fuera:</p>
          <p class="well">"...our intended use case for the UML was more modest: to be a language for reasoning about systems. In practice, one should throw away most UML diagrams; in practice, the architecture of even the most complex software-intensive system can be codified in a few dozen UML diagrams, thus capturing the essential design decisions.<br/><br/>Much more makes the UML a programming language, for which I certainly never intended it."</p>
          <p>Grady Booch dixit [1]. Así que, puestos a hacer comparaciones, quizá deberíamos empezar por asumir que, en realidad, el albañil del software no es el programador, sino el compilador. Obviamente, esto es una ventaja tremenda: los obreros de la informática no cobran, no hacen pausa para el bocadillo, no forman comités de empresa, construyen a una velocidad de vértigo y solo se quejan si no se les da una especificación que puedan interpretar. Si fuese arquitecto me moriría de envidia.</p>
          <p>Entonces, si el compilador hace las labores de albañil ¿qué diferencias hay entre las labores del diseñador y el programador? Si la fase de diseño tiene como objetivo producir una especificación que permita la construcción del software y asumimos que la única especificación válida es el código, la conclusión lógica es que los diseñadores son los programadores. ¡Vaya giro argumental!</p>
          <p>Si volvemos al origen de esta disertación, parece lógico pensar que a la hora de contratar a un diseñador/programador/tío-que-especifica-programas, lo verdaderamente importante es ver cómo piensa y si tiene los conocimientos adecuados para escribir la especificación de un sistema, y eso solo se ve en el código: si un tío escribe clases de 3.000 líneas, probablemente no sepa lo que es la segregación de interfaces o el principio de responsabilidad única; si escribe métodos con una ensalada de <i>if's</i> anidados, seguramente tampoco comprenda la idea de polimorfismo; si sus entidades son objetos sin comportamiento, es probable que tienda a diseñar modelos anémicos. Así que, pudiendo ver código ¿quién quiere un currículum?.</p>
          <p>En definitiva, y resumiendo todo esto: sería sabio dejar de ver la programación como una tarea menor que puede dejarse en manos de becarios imberbes contratados de cinco en cinco, porque por muchos diagramas UML que se hagan, el programa que se va a ejecutar en último término se habrá construido a partir del código fuente; tú verás en manos de quien lo dejas.</p>
          <p><strong>Notas:</strong></p>
          <p>[1] <a href="http://www.infoq.com/articles/booch-cope-interview">http://www.infoq.com/articles/booch-cope-interview</a></p>
        </div>
      </div>
    </div>
  </section>

  <footer id="footer">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <p>Copyright © 2014 Alfonso Pérez</p>
        </div>
      </div>
    </div>
  </footer>
</body>

</html>
